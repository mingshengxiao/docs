<h4>浏览器渲染原理</h4>

1. HTML被HTML解析器解析成DOM Tree
2. CSS被CSS解析器解析成CSSOM Tree
3. DOM Tree和CSSOM Tree解析完成后，被附加到一起，形成渲染树(Render Tree)
4. 布局，根据渲染树计算每个节点的几何信息生成布局树(Layout Tree)
5. 对布局树进行分层，并生成分层树(Layer Tree)
6. 为每个图层生成绘制列表
7. 渲染绘制(Paint).根据计算好的绘制列表信息绘制整个页面，并将其提交到合成线程
8. 合成线程将图层分成图块，并在光栅化线程中将图块转换成位图，发送绘制图块命令DrawQuad给浏览器进程
9. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

#### 重排

- 定义

当通过JS或css改变了元素的宽度、高度等，修改了元素的几何位置属性，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程叫重排。

#### 重绘

- 定义

如果修改了元素的背景颜色，并没有引起几何位置的变换，所有就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说<span stype="color: red;">重排一定会引起重绘，而重绘不一定会引起重排</span>，重绘的开销较小，重排的代价较高

#### 优化重排/重绘

- 减少DOM操作

1. 最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发重排。
2. 如果在一个局部方法中需要多次访问同一个dom，可以在第一次获取元素时用变量保存下来，减少遍历时间。
3. 用事件委托来减少事件处理器的数量。
4. 用querySelectorAll()替代getElementByXX()。

  querySelectorAll()：获取静态集合，通过函数获取元素之后，元素之后的改变并不会影响之前获取后存储到的变量。也就是获取到元素之后就和html中的这个元素没有关系了

  getElementByXX()：获取动态集合，通过函数获取元素之后，元素之后的改变还是会动态添加到已经获取的这个元素中。换句话说，通过这个方法获取到元素存储到变量的时候，以后每一次在Javascript函数中使用这个变量的时候都会再去访问一下这个变量对应的html元素。

- 减少重排

1. 放弃传统操作DOM的时代，基于vue/react开始数据影响视图模式。
2. 避免设置大量的style内联属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性。
3. 不要使用table布局，因为table中某个元素一旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。
4. 尽量少使用display：none可以使用visibility：hidden代替，display：none会造成重排，visibility：hidden只会造成重绘。
5. 使用resize事件时，做防抖和节流处理。
6. 分离读写操作（现代的浏览器都有渲染队列的机制）
